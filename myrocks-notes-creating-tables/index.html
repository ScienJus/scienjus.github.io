<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MyRocks 学习笔记之创建表 · ScienJus's Blog</title><meta name="description" content="MyRocks 学习笔记之创建表 - ScienJus"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.scienjus.com/atom.xml" title="ScienJus's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/ScienJus" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ScienJus" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MyRocks 学习笔记之创建表</h1><div class="post-info">Jul 21, 2019</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前网上介绍 MyRocks 的文章虽然不少，但是大部分都只介绍了一些 RocksDB 的核心特性和读写原理，却几乎不会提到 MyRocks 在实现 MySQL 存储引擎相关的内容，并且由于 MySQL 官方对于存储引擎的开发资料也提供的很单薄，所以对于新人来说难免有些手足无措。</p>
<p>这个系列希望通过从 MySQL 存储引擎的 API 作为起点，结合 MyRocks 的实现，记录下每一个功能的全貌，包括自定义的存储引擎在每一个 API 中具体需要实现哪些功能，以及 MyRocks 是如何通过 RocksDB 实现这些功能的，其优缺点是什么。希望能够帮助一些初学者（包括我自己）如何从零开始或是二次开发一个 MySQL 存储引擎。</p>
<p>这篇笔记是第一章，介绍了创建表（Creating Tables）的流程。</p>
<a id="more"></a>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>官方文档的 <a href="https://dev.mysql.com/doc/internals/en/creating-tables.html" target="_blank" rel="external">Creating Tables</a> 章节简要的介绍了自定义的存储引擎如何实现创建表的功能，只需要实现 <code>create</code> 这个虚函数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual int create(const char *name, TABLE *form, HA_CREATE_INFO *info)=0;</span><br></pre></td></tr></table></figure>
<p>存储引擎需要在这个函数中创建所有与表结构和索引结构相关的数据文件，它有三个参数：</p>
<ul>
<li><code>name</code>: 该表的表名</li>
<li><code>form</code>: 该表的元数据信息，主要包含表结构、字段和索引的信息</li>
<li><code>info</code>: 创建表时的额外的配置信息，基本都是 <code>CREATE TABLE</code> 时附带的选项</li>
</ul>
<h2 id="MyRocks-实现"><a href="#MyRocks-实现" class="headerlink" title="MyRocks 实现"></a>MyRocks 实现</h2><p>MyRocks 的实现在 <code>ha_rocksdb.cc</code> 的 <code>ha_rocksdb::create</code> 方法中。主要逻辑分为两部分：</p>
<ol>
<li>对用户提交的信息做一些转换和校验，拒绝 MyRocks 存储引擎不支持的配置</li>
<li>按照 MyRocks 的存储方式重新组织表结构和索引结构，并存储在内存和 RocksDB 中</li>
</ol>
<h3 id="前置处理"><a href="#前置处理" class="headerlink" title="前置处理"></a>前置处理</h3><p>MyRocks 首先会对创建表的配置信息进行前置处理，包括配置的检查和转换，拦截该存储引擎不支持的配置等，主要流程为：</p>
<ol>
<li><code>DATA DIRECTORY</code> 和 <code>INDEX DIRECTORY</code> 支持将该表的数据文件和索引文件存放在一个指定的路径。MyRocks 不支持这两个配置，而是通过 <code>rocksdb_datadir</code> 配置 RocksDB 存放数据的地址。</li>
<li>参数中的表名格式为 <code>./$dbname/$tablename</code>，MyRocks 会将其格式化为 <code>$dbname.$tablename</code>，便于之后处理。</li>
<li>解析 SQL 语句中是否含有外键定义，MyRocks 不支持外键，如果含有外键也会返回错误。</li>
</ol>
<p>接下来还需要检查当前这个表是否已经存在了，在 <code>TRUNCATE TABLE</code> 语句下需要删除重名的表信息，其他情况下报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Rdb_tbl_def *tbl = ddl_manager.find(str);</span><br><span class="line">if (tbl != nullptr) &#123;</span><br><span class="line">  if (thd-&gt;lex-&gt;sql_command == SQLCOM_TRUNCATE) &#123;</span><br><span class="line">    err = delete_table(tbl);</span><br><span class="line">    if (err != HA_EXIT_SUCCESS) &#123;</span><br><span class="line">      DBUG_RETURN(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    my_error(ER_METADATA_INCONSISTENCY, MYF(0), str.c_str(), name);</span><br><span class="line">    DBUG_RETURN(HA_ERR_ROCKSDB_CORRUPT_DATA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中包含两个细节：</p>
<p>什么时候会出现 <code>CREATE TABLE</code> 到存储引擎时，ddl_manager 中已经有了表的数据，却没有被上层拦截？</p>
<p>在<a href="https://github.com/facebook/mysql-5.6/issues/37" target="_blank" rel="external">这个 Issue </a>中提到了一个场景，即 frm 文件丢失（例如被人工删除）的情况，会进入该逻辑，需要做容错处理。</p>
<p>为什么需要判断 <code>sql_command == SQLCOM_TRUNCATE</code>，什么场景会出现？</p>
<p>通过看 <code>sql_truncate.cc</code> 中的逻辑猜测，如果存储引擎支持通过重建表实现 <code>TRUNCATE TABLE</code> 功能，那么上层会直接通过 <code>create</code> 方法创建一个结构完全相同的空表，而不是通过存储引擎实现的 <code>truncate</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool hton_can_recreate;</span><br><span class="line"></span><br><span class="line">if (lock_table(thd, table_ref, &amp;hton_can_recreate))</span><br><span class="line">  DBUG_RETURN(TRUE);</span><br><span class="line"></span><br><span class="line">if (hton_can_recreate)</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">    The storage engine can truncate the table by creating an</span><br><span class="line">    empty table with the same structure.</span><br><span class="line">  */</span><br><span class="line">  error= dd_recreate_table(thd, table_ref-&gt;db, table_ref-&gt;table_name);</span><br><span class="line"></span><br><span class="line">  if (thd-&gt;locked_tables_mode &amp;&amp; thd-&gt;locked_tables_list.reopen_tables(thd))</span><br><span class="line">      thd-&gt;locked_tables_list.unlink_all_closed_tables(thd, NULL, 0);</span><br><span class="line"></span><br><span class="line">  /* No need to binlog a failed truncate-by-recreate. */</span><br><span class="line">  binlog_stmt= !error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且 MyRocks 是支持 <code>HTON_CAN_RECREATE</code> 功能的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rocksdb_hton-&gt;flags = HTON_TEMPORARY_NOT_SUPPORTED |</span><br><span class="line">                      HTON_SUPPORTS_EXTENDED_KEYS | HTON_CAN_RECREATE;</span><br></pre></td></tr></table></figure>
<p>所以需要考虑到这种情况，删除当前该表的数据并继续执行创建流程。</p>
<h3 id="创建表和索引"><a href="#创建表和索引" class="headerlink" title="创建表和索引"></a>创建表和索引</h3><p>创建表和索引的主要流程也就是将表结构以及索引结构存储到硬盘的流程。其中 <code>ddl_manager</code> 对象就是 MyRocks 中对 RocksDB 操作的封装。顾名思义，这个类只负责 DDL 相关操作的存储。</p>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const std::unique_ptr&lt;rocksdb::WriteBatch&gt; wb = dict_manager.begin();</span><br></pre></td></tr></table></figure>
<p>WriteBatch 是 RocksDB 中原子操作和批量操作的封装类。之后所有对 RocksDB 的写入操作都将写入到该 WriteBatch 中，这样可以保证这些操作可以合并成一个原子操作提交到 RocksDB 中，不会出现一部分逻辑报错导致数据不一致的情况。</p>
<h4 id="设置隐藏主键"><a href="#设置隐藏主键" class="headerlink" title="设置隐藏主键"></a>设置隐藏主键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  If no primary key found, create a hidden PK and place it inside table</span><br><span class="line">  definition</span><br><span class="line">*/</span><br><span class="line">if (has_hidden_pk(table_arg)) &#123;</span><br><span class="line">  n_keys += 1;</span><br><span class="line">  // reset hidden pk id</span><br><span class="line">  // the starting valid value for hidden pk is 1</span><br><span class="line">  m_tbl_def-&gt;m_hidden_pk_val = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyRocks 支持表不设置主键，但是 RocksDB 底层的 KV 存储强依赖表的主键，所以在这里会自动增加隐藏主键列，并对上层透明。</p>
<h4 id="检查索引规范"><a href="#检查索引规范" class="headerlink" title="检查索引规范"></a>检查索引规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* MyRocks supports only the following collations for indexed columns */</span><br><span class="line">static const std::set&lt;const my_core::CHARSET_INFO *&gt; RDB_INDEX_COLLATIONS = &#123;</span><br><span class="line">    &amp;my_charset_bin, &amp;my_charset_utf8_bin, &amp;my_charset_latin1_bin&#125;;</span><br><span class="line"></span><br><span class="line">static bool rdb_is_index_collation_supported(</span><br><span class="line">    const my_core::Field *const field) &#123;</span><br><span class="line">  const my_core::enum_field_types type = field-&gt;real_type();</span><br><span class="line">  /* Handle [VAR](CHAR|BINARY) or TEXT|BLOB */</span><br><span class="line">  if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_STRING ||</span><br><span class="line">      type == MYSQL_TYPE_BLOB) &#123;</span><br><span class="line">    return RDB_INDEX_COLLATIONS.find(field-&gt;charset()) !=</span><br><span class="line">           RDB_INDEX_COLLATIONS.end();</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当索引字段为 <code>varchar/string/blob</code> 等字符类型时，MyRocks 只支持编码为 <code>binary/utf8_bin/latin1_bin</code>。</p>
<p>通过关闭 <code>rocksdb-strict-collat​​ion-check</code> 或是在 <code>rocksdb-strict-collat​​ion-exceptions</code> 配置表名可以跳过这个检查。</p>
<h4 id="创建-Column-Family"><a href="#创建-Column-Family" class="headerlink" title="创建 Column Family"></a>创建 Column Family</h4><p>在 RocksDB 中，每一个 KV 都会关联一个列族（Column Family，之后简称为 CF），而 MyRocks 是以索引为粒度存储 KV 数据的，所以支持为每个索引配置一个可选的 CF，默认存放在 <code>default</code> 中。</p>
<p>CF 的名称可以通过索引的整个注释内容或是 <code>cfname=$name</code> 选项进行配置，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sample (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    uid INT,</span><br><span class="line">    name VARCHAR(25),</span><br><span class="line">    ts TIMESTAMP,</span><br><span class="line">    KEY(`uid`) COMMENT &apos;cfname=cf_uid&apos;,</span><br><span class="line">    KEY(`name`) COMMENT &apos;cf_name&apos;</span><br><span class="line">) ENGINE=ROCKSDB</span><br></pre></td></tr></table></figure>
<p>其中 id 的主键索引会关联到 <code>default</code> CF 中，uid 的索引会关联到 <code>cf_uid</code> 中，而 name 的索引会关联到 <code>cf_name</code> 中。</p>
<p>在代码中的实现逻辑很简单，只是遍历每个索引，通过注释截取出 CF 的值。<br>CF 不能是 <code>__system__</code>，这个 CF 已经预留给了存放系统的数据，包括之后将会存放表结构和索引结构的数据。</p>
<p>在之前的版本中，还可以通过 <code>cfname=$per_index_cf</code> 自动生成格式为 <code>$tablename.$indexname</code> 的名称，但是在最新版本的代码中已经不支持了。</p>
<p>光从建表的流程中我们还不知道索引的 CF 具体的用途是什么，会在之后的写入数据的文章再详细介绍。</p>
<h4 id="读取-TTL-数据"><a href="#读取-TTL-数据" class="headerlink" title="读取 TTL 数据"></a>读取 TTL 数据</h4><p>因为 RocksDB 本身支持 TTL，所以 MyRocks 也支持在建表时设置每一条记录的 TTL 选项，通过表级别的注释 <code>ttl_duration=1;ttl_col=ts</code> 进行设置。</p>
<h4 id="生成索引-ID"><a href="#生成索引-ID" class="headerlink" title="生成索引 ID"></a>生成索引 ID</h4><p><code>Rdb_ddl_manager</code> 在内存中维护了一个自增的索引 id，启动时会从本地 RocksDB 中读取并初始化。当需要创建索引时，会通过调用 <code>get_and_update_next_number</code> 方法申请一个 id。其会在内存中加锁自增后写入 RocksDB，其格式为：</p>
<ul>
<li>Key：<code>Rdb_key_def::MAX_INDEX_ID</code></li>
<li>Value：<code>Rdb_key_def::MAX_INDEX_ID_VERSION, val</code></li>
</ul>
<h4 id="初始化自增起始值"><a href="#初始化自增起始值" class="headerlink" title="初始化自增起始值"></a>初始化自增起始值</h4><p>如果建表时指定自增主键的初始值 <code>auto_increment</code>，MyRocks 则会将其写入 system CF 中，格式为：</p>
<ul>
<li>Key：<code>Rdb_key_def::AUTO_INC, cf_id, index_id</code></li>
<li>Value：<code>Rdb_key_def::AUTO_INCREMENT_VERSION, auto_increment_value</code></li>
</ul>
<p>这里通过 RocksDB 的 merge operator 实现了更高性能的自增操作，不过建表时肯定是初始化，所以语义应该和 Put 相同。</p>
<h4 id="写入-CF-Flags"><a href="#写入-CF-Flags" class="headerlink" title="写入 CF Flags"></a>写入 CF Flags</h4><p>目前 MyRocks 有两个 CF 级别的配置，需要额外存储到以 CF 为单位的数据中，被称为 CF Flags，包括：</p>
<ol>
<li><code>is_per_partition_cf</code> 表示这个 CF 是否为某个分区表特定的 CF，例如配置 <code>p0_cfname=cf_p0</code>。</li>
<li><code>is_reverse_cf</code> 表示这个 CF 中存储的数据是否要反向存储，这样会使降序查询（<code>order by desc</code>）更快，配置方法是 <code>cfname=rev:xxx</code>。</li>
</ol>
<p>这两个 flag 分别占用 1bit，最终会合并保存在 RocksDB 中，格式为：</p>
<ul>
<li>Key：<code>Rdb_key_def::CF_DEFINITION, cf_id</code></li>
<li>Value：<code>Rdb_key_def::CF_DEFINITION_VERSION, flags</code></li>
</ul>
<p>因为多个索引可以共享同一个 CF，所以需要保证索引在创建时，CF 的配置不能和之前索引的冲突。</p>
<h4 id="写入索引信息"><a href="#写入索引信息" class="headerlink" title="写入索引信息"></a>写入索引信息</h4><p>在 <code>Rdb_dict_manager::add_or_update_index_cf_mapping</code> 方法中，会将每一个 Index 的信息存储在 RocksDB 中。</p>
<ul>
<li>Key：<code>Rdb_key_def::INDEX_INFO, cf_id, index_id</code></li>
<li>Value：<code>Rdb_key_def::INDEX_INFO_VERSION_LATEST, index_type, kv_version, index_flags, ttl_duration</code></li>
</ul>
<h4 id="写入表和索引的映射关系"><a href="#写入表和索引的映射关系" class="headerlink" title="写入表和索引的映射关系"></a>写入表和索引的映射关系</h4><p>在 <code>Rdb_tbl_def::put_dict</code> 中，会将一个表所对应的 CF 和 Index 存储到 RocksDB 中。</p>
<ul>
<li>Key：<code>Rdb_key_def::DDL_ENTRY_INDEX_START_NUMBER, db_table_name</code></li>
<li>Value：<code>DDL_ENTRY_INDEX_VERSION, cf_id1, index_id1[, cf_id2, index_id2...]</code></li>
</ul>
<h4 id="缓存表信息"><a href="#缓存表信息" class="headerlink" title="缓存表信息"></a>缓存表信息</h4><p>之后 <code>Rdb_ddl_manager::put</code> 方法会将这些信息同样缓存在内存中，便于之后其他操作使用，主要存放了两部分数据：</p>
<ol>
<li>在 <code>m_ddl_map</code> 中缓存 <code>db_table_name</code> 对应的 <code>Rdb_tbl_def</code></li>
<li>在 <code>m_index_num_to_keydef</code> 中缓存 <code>index_id, cf_id</code> 和 <code>db_table_name, index_no</code> 的映射关系</li>
</ol>
<h4 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h4><p>在所有操作处理完后，<code>Rdb_dict_manager::commit</code> 方法将以上所有的改动都通过 WriteBatch 提交到 RocksDB 中，同最开始提到的一样，这是一个原子操作，只会全部成功或是全部失败。</p>
<h2 id="实际验证"><a href="#实际验证" class="headerlink" title="实际验证"></a>实际验证</h2><p>光看代码肯定会存在遗漏或是理解错误的地方，接下来让我们实际创建一张表验证一下。</p>
<p>以下是用来测试的表，一共有四个字段、一个主键索引和两个普通索引，并且通过注释指定了 CF 和自增起始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sample (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    uid INT,</span><br><span class="line">    name VARCHAR(25),</span><br><span class="line">    ts TIMESTAMP,</span><br><span class="line">    KEY(`uid`) COMMENT &apos;cfname=cf_uid&apos;,</span><br><span class="line">    KEY(`name`) COMMENT &apos;cf_name&apos;</span><br><span class="line">) ENGINE=ROCKSDB AUTO_INCREMENT=100;</span><br></pre></td></tr></table></figure>
<p>创建成功后，我们查看一下存储在系统表中的 DDL 信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from INFORMATION_SCHEMA.ROCKSDB_DDL;</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/15637654866041.jpg" alt=""></p>
<p>接下来查看 RocksDB 当中的数据，并与上面的 DDL 信息以及代码分析进行比对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sst_dump --command=scan --file=&apos;000038.sst&apos; --output_hex</span><br><span class="line">from [] to []</span><br><span class="line">Process /var/lib/mysql/#rocksdb/000038.sst</span><br><span class="line">Sst file format: block-based</span><br><span class="line">&apos;00000001746573742E73616D706C65&apos; seq:16, type:1 =&gt; 0001000000000000010000000002000001010000000300000102</span><br><span class="line">&apos;000000020000000000000100&apos; seq:11, type:1 =&gt; 000601000D000000000000000000000000</span><br><span class="line">&apos;000000020000000200000101&apos; seq:13, type:1 =&gt; 000602000D000000000000000000000000</span><br><span class="line">&apos;000000020000000300000102&apos; seq:15, type:1 =&gt; 000602000D000000000000000000000000</span><br><span class="line">&apos;0000000300000000&apos; seq:6, type:1 =&gt; 000100000000</span><br><span class="line">&apos;0000000300000001&apos; seq:5, type:1 =&gt; 000100000000</span><br><span class="line">&apos;0000000300000002&apos; seq:12, type:1 =&gt; 000100000000</span><br><span class="line">&apos;0000000300000003&apos; seq:14, type:1 =&gt; 000100000000</span><br><span class="line">&apos;00000007&apos; seq:9, type:1 =&gt; 000100000102</span><br><span class="line">&apos;000000090000000000000100&apos; seq:10, type:2 =&gt; 00010000000000000064</span><br></pre></td></tr></table></figure>
<p>第一条数据为表和索引的对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000001               =&gt; 常量 DDL_ENTRY_INDEX_START_NUMBER</span><br><span class="line">746573742E73616D706C65 =&gt; &apos;test.sample&apos;，即库表名</span><br><span class="line"></span><br><span class="line">0001                   =&gt; 常量 DDL_ENTRY_INDEX_VERSION</span><br><span class="line">00000000               =&gt; 0，即 PRIMARY 的 cf id</span><br><span class="line">00000100               =&gt; 256，即 PRIMARY 的 index number</span><br><span class="line">00000002               =&gt; 2，即 uid 的 cf id</span><br><span class="line">00000101               =&gt; 257，即 uid 的 index number</span><br><span class="line">00000003               =&gt; 3，即 name 的 cf id</span><br><span class="line">00000102               =&gt; 258，即 name 的 index number</span><br></pre></td></tr></table></figure>
<p>第二条到第四条数据为索引信息，以第二条为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000002               =&gt; 常量 INDEX_INFO</span><br><span class="line">00000000               =&gt; 0，即 PRIMARY 的 cf id</span><br><span class="line">00000100               =&gt; 256，即 PRIMARY 的 index number</span><br><span class="line"></span><br><span class="line">0006                   =&gt; 常量 INDEX_INFO_VERSION_LATEST</span><br><span class="line">01                     =&gt; index type，1 是主键索引，2 是索引，3 是隐藏索引</span><br><span class="line">000D                   =&gt; kv format version，primary 和 secondary 都是 13</span><br><span class="line">00000000               =&gt; index flags，目前只有 TTL_FLAG</span><br><span class="line">0000000000000000       =&gt; ttl duration</span><br></pre></td></tr></table></figure>
<p>第五条到第八条数据为 CF 信息，以第五条为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000003               =&gt; 常量 CF_DEFINITION</span><br><span class="line">00000000               =&gt; cf 的 id</span><br><span class="line"></span><br><span class="line">0001                   =&gt; 常量 CF_DEFINITION_VERSION</span><br><span class="line">00000000               =&gt; cf flags，因为既没有分区也没有逆序，所以为 0</span><br></pre></td></tr></table></figure>
<p>第九条数据为当前系统内最大的索引 id：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000007               =&gt; 常量 MAX_INDEX_ID</span><br><span class="line"></span><br><span class="line">0001                   =&gt; 常量 MAX_INDEX_ID_VERSION</span><br><span class="line">00000102               =&gt; 当前系统最大的索引 id 是 258</span><br></pre></td></tr></table></figure>
<p>第十条数据是自增数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000009               =&gt; 常量 AUTO_INC</span><br><span class="line">00000000               =&gt; 0，即 PRIMARY 的 cf id</span><br><span class="line">00000100               =&gt; 256，即 PRIMARY 的 index number</span><br><span class="line"></span><br><span class="line">0001                   =&gt; 常量 AUTO_INCREMENT_VERSION</span><br><span class="line">0000000000000064       =&gt; 100，即设置的初始自增值</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://yq.aliyun.com/articles/62648" target="_blank" rel="external">myrocks记录格式分析</a></li>
<li><a href="http://mysql.taobao.org/monthly/2017/12/10/" target="_blank" rel="external">MySQL · myrocks · 相关tools介绍</a></li>
<li><a href="https://github.com/facebook/mysql-5.6/wiki/Schema-Design" target="_blank" rel="external">Schema Design</a></li>
<li><a href="https://github.com/facebook/mysql-5.6/wiki/Column-Families-on-Partitioned-Tables" target="_blank" rel="external">Column Families on Partitioned Tables</a></li>
<li><a href="https://github.com/facebook/mysql-5.6/wiki/MyRocks-Information-Schema" target="_blank" rel="external">MyRocks Information Schema</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/04/04/" target="_blank" rel="external">MySQL · MyRocks · TTL特性介绍</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/06/09/" target="_blank" rel="external">MySQL · RocksDB · Column Family介绍</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/09/09/" target="_blank" rel="external">MySQL · myrocks · collation 限制</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2019-year-end-review/" class="prev">上一篇</a><a href="/2018-year-end-review/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'scienjus';
var disqus_identifier = 'myrocks-notes-creating-tables/';
var disqus_title = 'MyRocks 学习笔记之创建表';
var disqus_url = 'http://www.scienjus.com/myrocks-notes-creating-tables/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//scienjus.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="http://www.scienjus.com">ScienJus</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-168066892-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47cf199e59a26235dadf455975b8b67f";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();</script></body></html>
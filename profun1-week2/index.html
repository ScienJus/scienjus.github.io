<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [Functional Programming Principles in Scala] 学习笔记（二） 高阶函数和类 · ScienJus's Blog</title><meta name="description" content="[Functional Programming Principles in Scala] 学习笔记（二） 高阶函数和类 - ScienJus"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.scienjus.com/atom.xml" title="ScienJus's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/ScienJus" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ScienJus" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[Functional Programming Principles in Scala] 学习笔记（二） 高阶函数和类</h1><div class="post-info">May 1, 2017</div><div class="post-content"><p>本周主要介绍了 Scala 中的高阶函数和类的相关定义，包含高阶函数和柯里化、类的构造与抽象等内容。</p>
<a id="more"></a>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>函数式语言将函数作为一等公民，这意味着函数可以像其他值一样作为参数或是返回值，这种做法提高了程序的灵活性。</p>
<p>将其他函数作为参数或者返回值的函数被称为高阶函数（Higher Order Functions）。</p>
<p>一个例子，下面这个方法用于计算两个整数之间的所有整数之和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumInts</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> a + sumInts(a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure>
<p>另一个方法用于计算两个整数之间的所有整数立方的和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x * x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumCubes</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> cube(a) + sumCubes(a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure>
<p>还有一个方法用于计算两个整数之间所有整数阶乘的和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> x * fact(x - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumFactorials</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> fact(a) + sumFactorials(a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure>
<p>可以看出，这三个方法的大部分模式都是相同的，它们都是通过递归获得 a 到 b 的所有整数，通过某个方法进行转换，最后将转换得到的值进行累加。</p>
<p>那么就可以将这个转换的函数提取成为方法参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> f(a) + sum(f, a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure>
<p>使用时在不同的实现中传入不同的函数即可：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumInts</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = sum(id, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x * x * x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumCubes</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = sum(cube, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> x * fact(x - <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumFactorials</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = sum(fact, a, b)</span><br></pre></td></tr></table></figure>
<p>在 Scala 中， <code>A =&gt; B</code> 代表一个接受一个 <code>A</code> 类型参数，并返回一个 <code>B</code> 类型参数的方法。例如上文中的 <code>Int =&gt; Int</code> 代表将一个整数转换为另一个整数的方法。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在使用高阶函数时，不可避免的需要定义很多小函数，但是其实很多时候不需要通过 <code>def</code> 定义函数并为其起一个名字。</p>
<p>以字符串举例，当需要打印一个常量字符串时，以下的代码是多余的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str</span> </span>= <span class="string">"ABC"</span></span><br><span class="line">println(str)</span><br></pre></td></tr></table></figure>
<p>它可以直接写为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"ABC"</span>)</span><br></pre></td></tr></table></figure>
<p>就像字符串一样，函数也可以作为一个常量存在，它们被称为匿名函数（Anonymous Functions）。</p>
<p>上文中 <code>cube</code> 的匿名函数形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x: <span class="type">Int</span>) =&gt; x * x * x</span><br></pre></td></tr></table></figure>
<p>其中 <code>(x: Int)</code> 是该函数的参数，<code>x * x * x</code> 是该函数的函数体。</p>
<p>如果函数有多个参数，那么彼此之间需要用 <code>,</code> 分隔，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure>
<p>如果函数的类型可以通过上下文推断得出，那么是可以省略的。</p>
<p>一个匿名函数 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x1 : T1, ..., xn : Tn) =&gt; E</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以被定义为一个形如</span><br></pre></td></tr></table></figure>
<p>{ def f(x1 : T1, …, xn : Tn) = E; f }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">的表达式，其中 `f` 是一个任意的未被占用的名称。所以可以把匿名函数当做一个语法糖（Syntactic Sugar）。</span><br><span class="line"></span><br><span class="line">通过匿名函数，上文中的方法又可以进一步简化：</span><br><span class="line"></span><br><span class="line">```scala</span><br><span class="line">def sumInts(a: Int, b: Int) = sum(x =&gt; x, a, b)</span><br><span class="line"></span><br><span class="line">def sumCubes(a: Int, b: Int) = sum(x =&gt; x * x * x, a, b)</span><br></pre></td></tr></table></figure></p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>再次观察上面的函数，它们是否还有进一步优化的空间？</p>
<p>在上面的函数实现中，参数 <code>a</code> 和 <code>b</code> 都没有经过任何处理，而是直接传到了 <code>sum</code> 函数中，是否有更好的写法隐藏这些参数呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>): (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumF</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> f(a) + sumF(a + <span class="number">1</span>, b)</span><br><span class="line">  sumF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个重写的函数不再接受两个 Int 类型的参数，而是直接将另一个函数作为了返回值，这个返回的函数才接受两个 Int 类型参数，并返回最终的结果。</p>
<p>上文中的函数定义将会变得更加简单：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumInts</span> </span>= sum(x =&gt; x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumCubes</span> </span>= sum(x =&gt; x * x * x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumFactorials</span> </span>= sum(fact)</span><br></pre></td></tr></table></figure>
<p>甚至可以避免定义这些中间变量，直接通过原始方法调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(cube)(<span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>在这当中 <code>sum(cube)</code> 返回了一个计算阶乘之和的方法，它和 <code>sumCubes</code> 是完全一样的，并且可以直接通过紧接着的 <code>(1, 10)</code> 参数调用这个方法。</p>
<p>在函数中返回另一个函数是非常有用的，为此 Scala 有一种特殊的语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>)(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> </span><br><span class="line">  <span class="keyword">else</span> f(a) + sum(f)(a + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure>
<p>这段方法和上面返回 <code>sumF</code> 的实现几乎是一样的，但是写起来更简洁。</p>
<p>如果定义了一个含有多个参数列表的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(args1)...(argsn) = <span class="type">E</span></span><br></pre></td></tr></table></figure>
<p>它实际等同于：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(args1)...(argsn−<span class="number">1</span>) = &#123; <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(argsn) = <span class="type">E</span>; g &#125;</span><br></pre></td></tr></table></figure>
<p>或是像匿名函数一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(args1)...(argsn−<span class="number">1</span>) =  (argsn ⇒ <span class="type">E</span>)</span><br></pre></td></tr></table></figure>
<p>往复替换 n 次之后，就会变为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= (args1 ⇒ (args2 ⇒ ...(argsn ⇒ <span class="type">E</span>)...)</span><br></pre></td></tr></table></figure>
<p>这种风格被称为柯里化（Currying）。</p>
<p>最终定义的 <code>sum</code> 方法的类型为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Int</span> =&gt; <span class="type">Int</span>) =&gt; (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">因为函数类型的关联是从右向左的，所以实际等同于：</span><br><span class="line"></span><br><span class="line">```scala</span><br><span class="line">(<span class="type">Int</span> =&gt; <span class="type">Int</span>) =&gt; ((<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Scala-语法汇总"><a href="#Scala-语法汇总" class="headerlink" title="Scala 语法汇总"></a>Scala 语法汇总</h2><p>以下定义中所用到的符号的含义为：</p>
<ul>
<li><code>|</code> ：替代关系</li>
<li><code>[...]</code> 0 或 1 个</li>
<li><code>{...}</code> 0 或 多个</li>
</ul>
<h3 id="类型（Types）"><a href="#类型（Types）" class="headerlink" title="类型（Types）"></a>类型（Types）</h3><p><img src="/uploads/types.png" alt="Types"></p>
<p>类型可以是：</p>
<ul>
<li>数字：Int、Double（Byte、Short、Char、Long、Float）</li>
<li>布尔：true 或 false</li>
<li>字符串</li>
<li>函数：像是 <code>Int =&gt; Int</code> 或者 <code>(Int, Int) =&gt; Int</code></li>
</ul>
<h3 id="表达式（Expressions）"><a href="#表达式（Expressions）" class="headerlink" title="表达式（Expressions）"></a>表达式（Expressions）</h3><p><img src="/uploads/expressions.png" alt="Expressions"></p>
<p>表达式可以是：</p>
<ul>
<li>标识符：例如 <code>x</code> 或是 <code>isGoodEnough</code></li>
<li>常量：例如 <code>0</code>、<code>1.0</code> 或是 <code>&quot;abc&quot;</code></li>
<li>执行函数：例如 <code>sqrt(x)</code></li>
<li>执行运算符：例如 <code>-x</code> 、<code>x + y</code></li>
<li>选择表达式：例如 <code>math.abs</code> （这里不太懂 <code>selection</code>是指的什么，该方法的内部实现是用的选择表达式？）</li>
<li>条件表达式：例如 <code>if (x &lt; 0) -x else x</code></li>
<li>代码块：例如 <code>{ val x = math.abs(y) ; x * 2 }</code></li>
<li>匿名函数：例如 <code>x =&gt; x + 1</code></li>
</ul>
<h3 id="定义（Definitions）"><a href="#定义（Definitions）" class="headerlink" title="定义（Definitions）"></a>定义（Definitions）</h3><p><img src="/uploads/definitions.png" alt="Definitions"></p>
<p>定义可以是：</p>
<ul>
<li>方法定义：例如 <code>def square(x: Int) = x</code></li>
<li>值定义：例如 <code>val y = square(2)</code></li>
</ul>
<p>其中参数可以是：</p>
<ul>
<li>值调用：例如 <code>(x: Int)</code></li>
<li>名称调用：例如 <code>(y: =&gt; Double)</code></li>
</ul>
<h2 id="函数和数据"><a href="#函数和数据" class="headerlink" title="函数和数据"></a>函数和数据</h2><p>本节通过一个例子介绍如何在 Scala 中使用函数创建和封装结构体。</p>
<p>一个分数由一个整数分子和另一个整数分母组成。如果需要计算两个分数的和，就需要定义两个如下的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addRationalNumerator</span></span>(n1: <span class="type">Int</span>, d1: <span class="type">Int</span>, n2: <span class="type">Int</span>, d2: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addRationalDenominator</span></span>(n1: <span class="type">Int</span>, d1: <span class="type">Int</span>, n2: <span class="type">Int</span>, d2: <span class="type">Int</span>): <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>但是这样做明显增加了代码的维护成本，一种更好的方式是将分子和分母共同维护在一个结构体中。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在 Scala 中，可以用下面这种方式定义一个类（Classes）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段定义包含了两部分：</p>
<ol>
<li>一个新的类型（Type）：Rational</li>
<li>一个可以用于创建 Rational 实例的构造方法（Constructor）</li>
</ol>
<p>Scala 会保证定义的名称和值在不同的命名空间（Namespace）中，所以多个 Rational 定义彼此之间不会冲突（？）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>每个类型的元素被称为对象（Objects），通过 <code>new</code> 加上构造方法可以创建一个新的对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>每个 Rational 对象都有两个成员变量（Members）：<code>numer</code> 和 <code>denom</code>。通过 <code>.</code> 操作符可以获取对象的成员变量：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>) &gt; x: <span class="type">Rational</span> = <span class="type">Rational</span>@<span class="number">2</span>abe0e27</span><br><span class="line">x.numer                    &gt; <span class="number">1</span></span><br><span class="line">x.denom                    &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在拥有 Rational 对象之后，就可以对其定义一些计算函数了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addRational</span></span>(r: <span class="type">Rational</span>, s: <span class="type">Rational</span>): <span class="type">Rational</span> =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Rational</span>(r.numer * s.denom + s.numer * r.denom, r.denom * s.denom)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeString</span></span>(r: <span class="type">Rational</span>) =</span><br><span class="line">  r.numer + ”/” + r.denom</span><br><span class="line">  </span><br><span class="line">makeString(addRational(<span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>, <span class="number">3</span>))) &gt; <span class="number">7</span>/<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>在此之上，还可以直接将函数抽象为结构体本身，这样的函数被称为方法（Methods）。</p>
<p>Rational 类本身就可以有 <code>add</code> 和 <code>toString</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(r: <span class="type">Rational</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * r.denom + r.numer * denom, denom * r.denom)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= numer + ”/” + denom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>toString</code> 是由 <code>java.lang.Object</code> 继承而来的方法，所以需要加上 <code>override</code> 关键词。</p>
<p>这样调用时就可以变为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> z = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">x.add(y).add(z)</span><br></pre></td></tr></table></figure>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>在上面的例子中，可以发现通过计算而得出的分数有可能不是最简形态（例如 <code>3/6</code> 可以被约为 <code>1/2</code>）。</p>
<p>为此我们可以在每一个计算分数的方法中都加入化简的逻辑，但是这会使代码难以维护，很有可能在某个计算中忘记加入这部分逻辑。</p>
<p>一个更好的办法是直接在构造分数时就进行化简：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(x, y)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x / g</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y / g</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法中的 <code>gcd</code> 和 <code>g</code> 都是私有成员，它们只能在该对象内部被访问到。</p>
<p>另一种方式是将 <code>numer</code> 和 <code>denom</code> 都声明为 <code>val</code>，然后直接用 <code>gcd</code> 方法去计算，这样可以保证 <code>numer</code> 和 <code>denom</code> 只会初始化一次：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> numer = x / gcd(x, y)</span><br><span class="line">  <span class="keyword">val</span> denom = y / gcd(x, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种方式对调用方都是无感知的，但是可以通过具体的情况选择不同的实现方案，这种方式称之为抽象（Abstraction）。</p>
<p>抽象是软件工程中的基石。</p>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><p>在类的内部可以使用 <code>this</code> 关键词指代当前执行方法的对象，也就是自引用（Self Reference）。</p>
<p>例如为 Rational 添加 <code>less</code> 和 <code>max</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;  ...  <span class="function"><span class="keyword">def</span> <span class="title">less</span></span>(that: <span class="type">Rational</span>) =    <span class="keyword">this</span>.numer * that.denom &lt; that.numer * <span class="keyword">this</span>.denom</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(that: <span class="type">Rational</span>) =    <span class="keyword">if</span> (<span class="keyword">this</span>.less(that)) that <span class="keyword">else</span> <span class="keyword">this</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前提检验"><a href="#前提检验" class="headerlink" title="前提检验"></a>前提检验</h3><p>假设 Rational 类要求分母必须是一个正整数，就可以通过 <code>require</code> 方法进行校验：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;  require(y &gt; <span class="number">0</span>, ”denominator must be positive”)  ...&#125;</span><br></pre></td></tr></table></figure>
<p><code>require</code> 是一个预定义方法，它需要一个条件以及可选的提示信息。当条件为假时，将会抛出一个携带提示信息的 <code>IllegalArgumentException</code> 异常。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>另一种校验的方式是使用断言（Assert），它同样接受一个条件和可选的提示信息，而当条件不满足时，它会抛出 <code>AssertionError</code> 异常。</p>
<p>两个异常的不同代表着这两种方式分别适合用于不同的场景：</p>
<ul>
<li><code>require</code> 适合在方法执行前校验外部传入的参数</li>
<li><code>assert</code> 用于校验方法执行过程中的逻辑</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 Scala 中，类定义就会隐式的引入一个构造函数，它被称为主构造函数（Primary Constructor）。</p>
<p>构造函数的主要用途是：</p>
<ul>
<li>接收传入的参数</li>
<li>执行类体中的所有语句</li>
</ul>
<p>除了主构造函数以外，还可以定义辅助构造函数，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(x: <span class="type">Int</span>) = <span class="keyword">this</span>(x, <span class="number">1</span>)  ...&#125;<span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>) &gt; <span class="number">2</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="类中的代换模型"><a href="#类中的代换模型" class="headerlink" title="类中的代换模型"></a>类中的代换模型</h2><p>在之前的笔记中有提到 Scala 的函数执行是通过一种称为代换模型的计算模型，在类和对象中也是如此。</p>
<p>当构建一个类实例 <code>new C(e1, ..., em)</code> 时，它的表达式参数依旧会像普通函数一样会被返回值所替代，成为 <code>new C(v1, ..., vm)</code>。</p>
<p>假设有一个包含方法的类定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">x1, ..., xm</span>)</span>&#123; ... <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(y1, ..., yn) = b ... &#125;</span><br></pre></td></tr></table></figure>
<p>它拥有类的形参 <code>x1, ..., xn</code> 和类实例方法的形参 <code>y1, ..., yn</code>，那么当执行 <code>new C(v1, ..., vm).f(w1, ..., wn)</code> 时，这整个表达式会被重写为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[w1/y1, ..., wn/yn][v1/x1, ..., vm/xm][<span class="keyword">new</span> <span class="type">C</span>(v1, ..., vm)/<span class="keyword">this</span>] b</span><br></pre></td></tr></table></figure>
<p>这里有三处地方被代换了：</p>
<ul>
<li><code>w1, ..., wn</code> 被代换为了方法 <code>f</code> 的形参 <code>y1, ..., yn</code></li>
<li><code>v1, ..., vn</code> 被代换为了类 <code>C</code> 的形参 <code>x1, ..., xm</code></li>
<li>表达式 <code>new C(v1, ..., vn)</code> 被代换为了自引用 <code>this</code></li>
</ul>
<p>以 Rational 作为一个具体的例子，当调用以下方法时：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>).less(<span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>首先会进行代换：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>/x, <span class="number">2</span>/y] [newRational(<span class="number">2</span>, <span class="number">3</span>)/that] [<span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)/<span class="keyword">this</span>]</span><br></pre></td></tr></table></figure>
<p>于是该方法的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.numer * that.denom &lt; that.numer * <span class="keyword">this</span>.denom</span><br></pre></td></tr></table></figure>
<p>就会被替换为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>).numer * <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>, <span class="number">3</span>).denom &lt; <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>, <span class="number">3</span>).numer * <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>).denom</span><br></pre></td></tr></table></figure>
<p>最后可以轻松的计算出结果：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="number">3</span> &lt; <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>原则上来说，通过 Rational 定义的分数和整数没有什么区别，但是在使用时却有一些差异。</p>
<p>当我们想要计算两个整数的和时，只需要调用 <code>x + y</code>，而当需要计算两个 Rational 的和时，却需要调用 <code>r.add(s)</code>。</p>
<p>在 Scala 中，可以通过两步消除这种差异。</p>
<h3 id="中缀运算"><a href="#中缀运算" class="headerlink" title="中缀运算"></a>中缀运算</h3><p>任何只有一个参数的方法都可以使用中缀运算符（Infix Operator）的方式进行调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r add s  = r.add(s)</span><br><span class="line">r less s = r.less(s)</span><br><span class="line">r max s  = r.max(s)</span><br></pre></td></tr></table></figure>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>在 Scala 中标识符可以有两种形态：</p>
<ul>
<li>字母数字（Alphanumeric）：以字母为起始字符，字母和数字组成的序列</li>
<li>符号（Symbolic）：以一个运算符为起始字符，后面可以跟着其他的运算符</li>
<li>下划线（<code>_</code>）也算是字母的一种</li>
<li>字母数字的标识符可以以下划线结尾，之后跟着一些运算符，例如 <code>vector_++</code></li>
</ul>
<p>所以 Rational 类中的部分方法可以通过运算符进行替换：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(x, y)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x / g</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y / g</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span> </span>(r: <span class="type">Rational</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * r.denom + r.numer * denom, denom * r.denom)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-</span> </span>(r: <span class="type">Rational</span>) = ...</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">*</span> </span>(r: <span class="type">Rational</span>) = ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使用时就可以像 Int 或是 Double 一样了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val x = new Rational(1, 2)</span><br><span class="line">val y = new Rational(1, 3)</span><br><span class="line"></span><br><span class="line">(x * x) + (y * y)</span><br></pre></td></tr></table></figure>
<p>运算符的优先级由其第一个字符决定，下图为优先级有低至高的运算符。</p>
<p><img src="/uploads/precedence.png" alt="precedence"></p>
</div></article></div></main><footer><div class="paginator"><a href="/document-apache-thrift/" class="prev">PREV</a><a href="/moved-blog-to-github-pages/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'scienjus';
var disqus_identifier = 'profun1-week2/';
var disqus_title = '[Functional Programming Principles in Scala] 学习笔记（二） 高阶函数和类';
var disqus_url = 'http://www.scienjus.com/profun1-week2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//scienjus.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="http://www.scienjus.com">ScienJus</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-168066892-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47cf199e59a26235dadf455975b8b67f";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();</script></body></html>